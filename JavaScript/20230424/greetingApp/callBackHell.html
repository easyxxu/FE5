<!DOCTYPE html>
<html lang="ko-KR">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>callback hell</title>
</head>

<body>
    <script>
        'use strict';

        class UserStorage {
            searchUser(userName, password, onSuccess, onError) {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', 'users.json');
                xhr.onreadystatechange = () => {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        // 통신 성공 후 가져온 데이터를 가공하는 코드
                        const result = JSON.parse(xhr.responseText).user.find((item) => {
                            return item.userName === userName && item.password === password
                        });
                        if (result) {
                            onSuccess(userName);
                        } else {
                            onError(new Error('user not found'));

                        }
                    }
                }
                xhr.send();
            }
            // 등록된 유저에 따른 인사말을 출력
            sayHi(user, onSuccess, onError) {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', 'greetings.json');
                xhr.onreadystatechange = () => {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        // 통신 성공 후 가져온 데이터를 가공하는 코드
                        const result = JSON.parse(xhr.responseText).greetings.find((item) => {
                            return item.userName === user
                        });
                        if (result) {
                            onSuccess({ name: result.userName, greetings: result.greetings });
                        } else {
                            onError(new Error('no greetings'));

                        }
                    }
                }
                xhr.send();
            }

        }
        const userStorage = new UserStorage(); //userstorage 인스턴스가 생성됨
        const userName = prompt('이름을 입력해주세요');
        const password = prompt('비밀번호를 입력해주세요');
        userStorage.searchUser(userName,
            password,
            (name) => {
                userStorage.sayHi(
                    name,
                    (result) => { alert(`당신에게 인사합니다! ${result.name}님 ${result.greetings}`) },
                    (error) => {
                        console.log(error);
                    }
                )
            }, (error) => console.log(error));
            //브라우저나 자스는 싱글스레드 환경에서 실행됨 = 사용자의 코드를 브라우저가 실행을 시킬때 반드시 순서대로 실행시키고 만약 1,2,3함수가 있는 경우 1이 실행되는 경우 2가 실행될 수 없고 1->2->3 순서대로 실행이 되어야함 함수가 실행되는 장소를 메인 쓰레드라고 함. 문제는 메인쓰레드 위에 시간이 오래걸리는 함수가 있다면 그 뒤에 있는 함수는 모두 블록킹(실행중단) 메인쓰레드 하나만 있다면 프로그램 자체가 느려져서 사이드 쓰레드라는 것을 만듦. 사이드 쓰레드는 특정 조건이 있어야 함(비동기가 실행될 때) 메인과 사이드는 각각 따로 실행하게 된다. setTimeout 함수 의 시간만큼 사이드 쓰레드에서 실행이 됨. 타임아웃이나 통신이 끝나고나면 함수들이 메인쓰레드로 다시 실행이 되고 사이드쓰레드는 사라짐 그래서 콘솔로 여러번 찍어도 비동기가 나중에 실행되는 것임. 충돌을 발생시키지 않기 위해 자스안에서 관리를 해줌(=>이벤트루프, 매니저라고 생각하면 됨) 메인과 사이드가 서로 충돌하지 않게 관리해줌 이벤트루프가 조절을 해준느데 사이드에서 실행하고 메인으로 오게 되면 메인에서 실행중인 함수가 실행되고 나서 실행할 수 있도록 조절함.
    </script>
</body>

</html>